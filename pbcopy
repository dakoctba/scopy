// processor.go
package pkg

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Config contém as configurações para o processamento de arquivos
type Config struct {
	HeaderFormat    string
	ExcludePatterns []string
	ListOnly        bool
	MaxSize         int64
	StripComments   bool
	Extensions      []string
}

// Processor é responsável por processar os arquivos
type Processor struct {
	config Config
	stats  Stats
}

// Stats contém as estatísticas do processamento
type Stats struct {
	TotalFiles int
	FilesByExt map[string]int
	TotalBytes int64
	TotalLines int
}

// NewProcessor cria uma nova instância do Processor
func NewProcessor(config Config) *Processor {
	return &Processor{
		config: config,
		stats: Stats{
			FilesByExt: make(map[string]int),
		},
	}
}

// Process inicia o processamento dos arquivos
func (p *Processor) Process() error {
	return filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Ignora diretórios
		if info.IsDir() {
			return nil
		}

		// Verifica se o arquivo deve ser excluído
		if p.shouldExclude(path) {
			return nil
		}

		// Verifica a extensão do arquivo
		ext := strings.ToLower(filepath.Ext(path))
		if !p.hasValidExtension(ext) {
			return nil
		}

		// Verifica o tamanho máximo
		if p.config.MaxSize > 0 && info.Size() > p.config.MaxSize {
			return nil
		}

		// Atualiza estatísticas
		p.stats.TotalFiles++
		p.stats.FilesByExt[ext]++
		p.stats.TotalBytes += info.Size()

		// Se for apenas listar, imprime o caminho e retorna
		if p.config.ListOnly {
			fmt.Println(path)
			return nil
		}

		// Processa o arquivo
		return p.processFile(path)
	})
}

// GetStats retorna as estatísticas do processamento
func (p *Processor) GetStats() Stats {
	return p.stats
}

func (p *Processor) shouldExclude(path string) bool {
	for _, pattern := range p.config.ExcludePatterns {
		if pattern != "" && strings.Contains(path, pattern) {
			return true
		}
	}
	return false
}

func (p *Processor) hasValidExtension(ext string) bool {
	if ext == "" {
		return false
	}

	// Remove o ponto da extensão se presente
	ext = strings.TrimPrefix(ext, ".")

	for _, validExt := range p.config.Extensions {
		// Remove o ponto da extensão válida se presente
		validExt = strings.TrimPrefix(validExt, ".")
		if strings.ToLower(validExt) == ext {
			return true
		}
	}
	return false
}

func (p *Processor) processFile(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// Imprime o cabeçalho
	fmt.Printf(p.config.HeaderFormat+"\n", path)

	// Copia o conteúdo do arquivo
	_, err = io.Copy(os.Stdout, file)
	if err != nil {
		return err
	}

	fmt.Println() // Adiciona uma linha em branco entre arquivos
	return nil
}

// processor_test.go
package pkg

import (
	"os"
	"path/filepath"
	"testing"
)

func TestProcessor(t *testing.T) {
	// Cria um diretório temporário para os testes
	tempDir, err := os.MkdirTemp("", "scopy-test-")
	if err != nil {
		t.Fatalf("Erro ao criar diretório temporário: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Cria alguns arquivos de teste
	testFiles := []struct {
		name    string
		content string
		ext     string
	}{
		{"test1.go", "package main\n\nfunc main() {}\n", ".go"},
		{"test2.js", "function test() {}\n", ".js"},
		{"test3.txt", "Este é um arquivo de texto\n", ".txt"},
	}

	for _, tf := range testFiles {
		path := filepath.Join(tempDir, tf.name)
		err := os.WriteFile(path, []byte(tf.content), 0644)
		if err != nil {
			t.Fatalf("Erro ao criar arquivo de teste %s: %v", tf.name, err)
		}
	}

	// Testa o processador
	config := Config{
		HeaderFormat:    "// %s",
		ExcludePatterns: []string{},
		ListOnly:        false,
		MaxSize:         0,
		StripComments:   false,
		Extensions:      []string{"go", "js"},
	}

	processor := NewProcessor(config)
	err = processor.Process()
	if err != nil {
		t.Errorf("Erro ao processar arquivos: %v", err)
	}

	// Verifica as estatísticas
	stats := processor.GetStats()
	if stats.TotalFiles != 2 {
		t.Errorf("Número incorreto de arquivos processados: esperado 2, obtido %d", stats.TotalFiles)
	}

	if stats.FilesByExt[".go"] != 1 {
		t.Errorf("Número incorreto de arquivos .go: esperado 1, obtido %d", stats.FilesByExt[".go"])
	}

	if stats.FilesByExt[".js"] != 1 {
		t.Errorf("Número incorreto de arquivos .js: esperado 1, obtido %d", stats.FilesByExt[".js"])
	}
}

func TestExcludePatterns(t *testing.T) {
	// Cria um diretório temporário para os testes
	tempDir, err := os.MkdirTemp("", "scopy-test-")
	if err != nil {
		t.Fatalf("Erro ao criar diretório temporário: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Cria um arquivo de teste em um subdiretório
	subDir := filepath.Join(tempDir, "exclude")
	err = os.Mkdir(subDir, 0755)
	if err != nil {
		t.Fatalf("Erro ao criar subdiretório: %v", err)
	}

	path := filepath.Join(subDir, "test.go")
	err = os.WriteFile(path, []byte("package main\n\nfunc main() {}\n"), 0644)
	if err != nil {
		t.Fatalf("Erro ao criar arquivo de teste: %v", err)
	}

	// Testa o processador com padrão de exclusão
	config := Config{
		HeaderFormat:    "// %s",
		ExcludePatterns: []string{"exclude"},
		ListOnly:        false,
		MaxSize:         0,
		StripComments:   false,
		Extensions:      []string{"go"},
	}

	processor := NewProcessor(config)
	err = processor.Process()
	if err != nil {
		t.Errorf("Erro ao processar arquivos: %v", err)
	}

	// Verifica que o arquivo foi excluído
	stats := processor.GetStats()
	if stats.TotalFiles != 0 {
		t.Errorf("Arquivo não foi excluído corretamente: %d arquivos processados", stats.TotalFiles)
	}
}

--- FAIL: TestProcessor (0.00s)
    processor_test.go:59: Número incorreto de arquivos .go: esperado 1, obtido 2
    processor_test.go:63: Número incorreto de arquivos .js: esperado 1, obtido 0
// processor.go
package pkg

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

// Config contém as configurações para o processamento de arquivos
type Config struct {
	HeaderFormat    string
	ExcludePatterns []string
	ListOnly        bool
	MaxSize         int64
	StripComments   bool
	Extensions      []string
}

// Processor é responsável por processar os arquivos
type Processor struct {
	config Config
	stats  Stats
}

// Stats contém as estatísticas do processamento
type Stats struct {
	TotalFiles int
	FilesByExt map[string]int
	TotalBytes int64
	TotalLines int
}

// NewProcessor cria uma nova instância do Processor
func NewProcessor(config Config) *Processor {
	return &Processor{
		config: config,
		stats: Stats{
			FilesByExt: make(map[string]int),
		},
	}
}

// Process inicia o processamento dos arquivos
func (p *Processor) Process() error {
	return filepath.Walk(".", func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Ignora diretórios
		if info.IsDir() {
			return nil
		}

		// Verifica se o arquivo deve ser excluído
		if p.shouldExclude(path) {
			return nil
		}

		// Verifica a extensão do arquivo
		ext := strings.ToLower(filepath.Ext(path))
		if !p.hasValidExtension(ext) {
			return nil
		}

		// Verifica o tamanho máximo
		if p.config.MaxSize > 0 && info.Size() > p.config.MaxSize {
			return nil
		}

		// Atualiza estatísticas
		p.stats.TotalFiles++
		p.stats.FilesByExt[ext]++
		p.stats.TotalBytes += info.Size()

		// Se for apenas listar, imprime o caminho e retorna
		if p.config.ListOnly {
			fmt.Println(path)
			return nil
		}

		// Processa o arquivo
		return p.processFile(path)
	})
}

// GetStats retorna as estatísticas do processamento
func (p *Processor) GetStats() Stats {
	return p.stats
}

func (p *Processor) shouldExclude(path string) bool {
	for _, pattern := range p.config.ExcludePatterns {
		if pattern != "" && strings.Contains(path, pattern) {
			return true
		}
	}
	return false
}

func (p *Processor) hasValidExtension(ext string) bool {
	if ext == "" {
		return false
	}

	// Remove o ponto da extensão se presente
	ext = strings.TrimPrefix(ext, ".")

	for _, validExt := range p.config.Extensions {
		// Remove o ponto da extensão válida se presente
		validExt = strings.TrimPrefix(validExt, ".")
		if strings.ToLower(validExt) == ext {
			return true
		}
	}
	return false
}

func (p *Processor) processFile(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	// Imprime o cabeçalho
	fmt.Printf(p.config.HeaderFormat+"\n", path)

	// Copia o conteúdo do arquivo
	_, err = io.Copy(os.Stdout, file)
	if err != nil {
		return err
	}

	fmt.Println() // Adiciona uma linha em branco entre arquivos
	return nil
}

// processor_test.go
package pkg

import (
	"os"
	"path/filepath"
	"testing"
)

func TestProcessor(t *testing.T) {
	// Cria um diretório temporário para os testes
	tempDir, err := os.MkdirTemp("", "scopy-test-")
	if err != nil {
		t.Fatalf("Erro ao criar diretório temporário: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Cria alguns arquivos de teste
	testFiles := []struct {
		name    string
		content string
		ext     string
	}{
		{"test1.go", "package main\n\nfunc main() {}\n", ".go"},
		{"test2.js", "function test() {}\n", ".js"},
		{"test3.txt", "Este é um arquivo de texto\n", ".txt"},
	}

	for _, tf := range testFiles {
		path := filepath.Join(tempDir, tf.name)
		err := os.WriteFile(path, []byte(tf.content), 0644)
		if err != nil {
			t.Fatalf("Erro ao criar arquivo de teste %s: %v", tf.name, err)
		}
	}

	// Testa o processador
	config := Config{
		HeaderFormat:    "// %s",
		ExcludePatterns: []string{},
		ListOnly:        false,
		MaxSize:         0,
		StripComments:   false,
		Extensions:      []string{"go", "js"},
	}

	processor := NewProcessor(config)
	err = processor.Process()
	if err != nil {
		t.Errorf("Erro ao processar arquivos: %v", err)
	}

	// Verifica as estatísticas
	stats := processor.GetStats()
	if stats.TotalFiles != 2 {
		t.Errorf("Número incorreto de arquivos processados: esperado 2, obtido %d", stats.TotalFiles)
	}

	if stats.FilesByExt[".go"] != 1 {
		t.Errorf("Número incorreto de arquivos .go: esperado 1, obtido %d", stats.FilesByExt[".go"])
	}

	if stats.FilesByExt[".js"] != 1 {
		t.Errorf("Número incorreto de arquivos .js: esperado 1, obtido %d", stats.FilesByExt[".js"])
	}
}

func TestExcludePatterns(t *testing.T) {
	// Cria um diretório temporário para os testes
	tempDir, err := os.MkdirTemp("", "scopy-test-")
	if err != nil {
		t.Fatalf("Erro ao criar diretório temporário: %v", err)
	}
	defer os.RemoveAll(tempDir)

	// Cria um arquivo de teste em um subdiretório
	subDir := filepath.Join(tempDir, "exclude")
	err = os.Mkdir(subDir, 0755)
	if err != nil {
		t.Fatalf("Erro ao criar subdiretório: %v", err)
	}

	path := filepath.Join(subDir, "test.go")
	err = os.WriteFile(path, []byte("package main\n\nfunc main() {}\n"), 0644)
	if err != nil {
		t.Fatalf("Erro ao criar arquivo de teste: %v", err)
	}

	// Testa o processador com padrão de exclusão
	config := Config{
		HeaderFormat:    "// %s",
		ExcludePatterns: []string{"exclude"},
		ListOnly:        false,
		MaxSize:         0,
		StripComments:   false,
		Extensions:      []string{"go"},
	}

	processor := NewProcessor(config)
	err = processor.Process()
	if err != nil {
		t.Errorf("Erro ao processar arquivos: %v", err)
	}

	// Verifica que o arquivo foi excluído
	stats := processor.GetStats()
	if stats.TotalFiles != 0 {
		t.Errorf("Arquivo não foi excluído corretamente: %d arquivos processados", stats.TotalFiles)
	}
}

--- FAIL: TestExcludePatterns (0.00s)
    processor_test.go:107: Arquivo não foi excluído corretamente: 2 arquivos processados
FAIL
FAIL	github.com/dakoctba/scopy/pkg	0.200s
FAIL
